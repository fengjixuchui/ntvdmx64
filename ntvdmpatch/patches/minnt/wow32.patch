--- NT4\private\mvdm\wow32\hack.c
+++ nt\private\mvdm\wow32\hack.c
201a202,205
> #ifdef W10 /* On Win10, this calls RtlAllocateHeap internally. If we use ZwAllocate instead, we will crash on free */
>         if (lpEnvNew = RtlAllocateHeap(GetProcessHeap(), 0, MemoryInformation.RegionSize))
>             Status = STATUS_SUCCESS; else Status = STATUS_NO_MEMORY;
> #else
207a212
> #endif
--- NT4\private\mvdm\wow32\wshimdb.c
+++ nt\private\mvdm\wow32\wshimdb.c
499a500,503
> #ifdef W10 /* On Win10, this calls RtlAllocateHeap internally. If we use ZwAllocate instead, we will crash on free */
>         if (lpEnvNew = RtlAllocateHeap(GetProcessHeap(), 0, MemoryInformation.RegionSize))
>             Status = STATUS_SUCCESS; else Status = STATUS_NO_MEMORY;
> #else
505a510
> #endif
--- NT4\private\mvdm\wow32\intthunk.c
+++ nt\private\mvdm\wow32\intthunk.c
51a52,54
>     #ifdef W10
>     DECLARE_THUNKLOCK
>     #endif
165a169,171
>     #ifdef W10	// Win32 functions can Send messages to 16bit window, so these windows must be able to reply
> 	if (((*pbInstr & IT_HUSER)  || (*pbInstr & IT_HGDI))) { RELEASE_THUNKLOCK; }
>     #endif
174a182,184
>     #ifdef W10
>     if (((*pbInstr & IT_HUSER)  || (*pbInstr & IT_HGDI))) { RESTORE_THUNKLOCK; }
>     #endif
--- NT4\private\mvdm\wow32\wcall16.c
+++ nt\private\mvdm\wow32\wcall16.c
844a845,847
> #ifdef W10
>     _EnterWin16Lock();
> #endif
858a864,866
> #ifdef W10
>      _LeaveWin16Lock();
> #endif
--- NT4\private\mvdm\wow32\wcommdlg.c
+++ nt\private\mvdm\wow32\wcommdlg.c
2088a2089
>     DECLARE_THUNKLOCK
2207a2209
>     RELEASE_THUNKLOCK
2208a2211
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wddeml32.c
+++ nt\private\mvdm\wow32\wddeml32.c
211a212
>     DECLARE_THUNKLOCK
217a219
>     RELEASE_THUNKLOCK
219a222
>     RESTORE_THUNKLOCK
367a371
>     DECLARE_THUNKLOCK
380a385
>         RELEASE_THUNKLOCK
388a394
>         RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wumsg.c
+++ nt\private\mvdm\wow32\wumsg.c
174a175
>     DECLARE_THUNKLOCK
224a226
>             RELEASE_THUNKLOCK
227a230
>             RESTORE_THUNKLOCK
431a435
>     DECLARE_THUNKLOCK
477a482
>             RELEASE_THUNKLOCK
480a486
>             RESTORE_THUNKLOCK
662a669,671
> #ifdef W10
>         _LeaveWin16Lock();
> #endif
663a673,675
> #ifdef W10
>         _EnterWin16Lock();
> #endif
712a725
>     DECLARE_THUNKLOCK
730a744
>     RELEASE_THUNKLOCK
731a746
>     RESTORE_THUNKLOCK
820a836
>     DECLARE_THUNKLOCK
831c847,853
< 
---
> #ifdef W10
>     if (!PeekMessage(&t1, HWND32(parg16->hwnd), WORD32(parg16->wMin), WORD32(parg16->wMax), PM_REMOVE))
>     {
>          DWORD count;
>          
>          ReleaseThunkLock(&count);
> #endif
835a858,862
> #ifdef W10
>         RestoreThunkLock(count);
>     }
>     else ul = t1.message != WM_QUIT;
> #endif
844a872
> #ifndef W10 /* msctf.dll also seems to use high timer IDs. Therefore removed check */
848a877
> #endif
849a879,883
>     LOGDEBUG(LOG_TRACE,("hWnd = %x, msg %d (0x%x), wParam=%08X, lParam=%08X\n", t1.hwnd, t1.message, t1.message, t1.wParam, t1.lParam)); 
> 
> #ifdef W10	/* Filter WM_TIMER that are useless for 16bit world */
>     if (t1.message != WM_TIMER || HIWORD(t1.wParam) == 0)
> #endif
1115a1150
>     DECLARE_THUNKLOCK
1131a1167,1175
> #ifdef W10
>     if (!fNoYield)
>     {
>         RELEASE_THUNKLOCK
>         //MsgWaitForMultipleObjects(0, NULL, FALSE, 0, QS_ALLINPUT);
>         Sleep(0);
>     }
> #endif
> 
1132a1177,1179
> #ifdef W10
>     if (!fNoYield) RESTORE_THUNKLOCK  // PeekMessage can call WndProc which can be 16bit code, therefore lock again 
> #endif
1700a1748,1751
> #ifdef W10
>     DECLARE_THUNKLOCK
>     LRESULT lResult;
> #endif
1760a1812,1821
> #ifdef W10
>             RELEASE_THUNKLOCK
>             lResult = SendMessageTimeout(hwndItem, mpex.uMsg, mpex.uParam,
>                                          mpex.lParam, SMTO_NORMAL, 1000, &mpex.lReturn);
>             RESTORE_THUNKLOCK
>             if (!lResult && GetLastError() == ERROR_TIMEOUT)
>             {
>                 LOGDEBUG(LOG_ALWAYS,("BUGBUG: SendDlgItemMessage(%p,%d,%04x,%08x,uTimeout=1000ms) timed out.\n", hwnd, mpex.uMsg, mpex.uParam, mpex.lParam));
>             }
> #else
1762a1824
> #endif
1825a1888,1891
> #ifdef W10
>     DECLARE_THUNKLOCK
>     LRESULT lResult;
> #endif
1904a1971,1982
> #ifdef W10
>         {
>             DWORD count;
>             ReleaseThunkLock(&count);
>             lResult = SendMessageTimeout(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam, SMTO_NORMAL, 1000, &mpex.lReturn);
>             RestoreThunkLock(count);
>             if (!lResult && GetLastError() == ERROR_TIMEOUT)
>             {
>                 LOGDEBUG(LOG_ALWAYS,("BUGBUG: SendMessage(%p,%d,%04x,%08x,uTimeout=1000ms) timed out.\n", hwnd, mpex.uMsg, mpex.uParam, mpex.lParam));
>             }
>         }
> #else
1905a1984
> #endif
2177a2257
>     DECLARE_THUNKLOCK
2180a2261
>     RELEASE_THUNKLOCK
2184a2266
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wkman.c
+++ nt\private\mvdm\wow32\wkman.c
33a34,44
> #ifndef GetAllUsersProfileDirectory
> USERENVAPI BOOL WINAPI GetAllUsersProfileDirectoryA(LPSTR lpProfileDir, LPDWORD lpcchSize);
> USERENVAPI BOOL WINAPI GetAllUsersProfileDirectoryW(LPWSTR lpProfileDir, LPDWORD lpcchSize);
> #ifdef UNICODE
> #define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryW
> #else
> #define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryA
> #endif // !UNICODE
> #endif 
> 
> 
1022a1034,1047
> #ifdef W10
> void InputIdleCB(HWND Arg1, UINT Arg2, UINT_PTR Arg3, DWORD Arg4)
> {
> #ifdef DEBUG
> 	register PVDMFRAME pFrame;
> 
>     PTD ptd = CURRENTPTD();
> 	GETFRAMEPTR(ptd->vpStack, pFrame);
> #endif
>     LOGDEBUG(LOG_TRACE,("%04X          InputIdleCB\n", pFrame->wTDB));
>     KillTimer(Arg1, Arg3);
>     WOW32VERIFY(SetEvent(ghevWaitCreatorThread));
> }
> #endif
1055a1081,1083
> #ifdef W10
>         DWORD mutex_count;
> #endif
1061a1090,1106
> #ifdef W10
>         ReleaseThunkLock(&mutex_count);
>         while ((dw = MsgWaitForMultipleObjects(2, ThreadEvents, FALSE, INFINITE, QS_SENDMESSAGE)) == WAIT_OBJECT_0+2)
>         {
>             MSG msg;
>             DECLARE_THUNKLOCK
>             
>             RESTORE_THUNKLOCK
>             if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
>             {
>                 TranslateMessage(&msg);
>                 DispatchMessage(&msg);
>             }
>             RELEASE_THUNKLOCK
>         }
>         RestoreThunkLock(mutex_count);
> #else
1062a1108,1109
> #endif
>         LOGDEBUG(LOG_TRACE,("%04X          Wait returned %d\n", pFrame->wTDB, dw));
1063a1111
> #ifndef W10 // Do not assert, as this constellation can occur due to InputIdle logic for ghevWaitCreatorThread
1066a1115
> #endif
1320c1369
<     CURRENTPTD() = &td;
---
>     SETCURRENTPTD(&td);
1505,1508c1554
<         
<         // FIXME: Enable the following when we are ready.
<         gfTaskContinue = TRUE;
<         //gfTaskContinue = CheckAppHelpInfo(&td,szFilePath,szModName);
---
>         gfTaskContinue = CheckAppHelpInfo(&td,szFilePath,szModName);
1561c1607
< #ifdef i386
---
> #ifdef i386xx
1569a1616
> #ifndef W10 /* Unfortunetely, no NtUserInitTask support... */
1604a1652,1654
> #else
>         {
>             static BOOL bFirstCall = TRUE;
1605a1656,1670
>             if (bFirstCall)
>             {
>                 HMODULE hUxTheme = GetModuleHandle("uxtheme.dll");
>                 if (!hUxTheme) hUxTheme = LoadLibrary("uxtheme.dll");
>                 if (hUxTheme)
>                 {
>                     typedef int (__stdcall *pfAddThemeAppCompatFlags)(ULONG ulAppCompatFlags, ULONG ulAppCompatFlagsEx);
>                     pfAddThemeAppCompatFlags AddThemeAppCompatFlags = (pfAddThemeAppCompatFlags)GetProcAddress(hUxTheme, (LPCSTR)67);
>                     if (AddThemeAppCompatFlags) AddThemeAppCompatFlags(2, 0);
>                     bFirstCall = FALSE;
>                 }
>             }
>         }
>         fRet = FALSE;
> #endif
1607a1673
>         td.hThread = hThread;
1626a1693,1694
> #ifdef W10
>             SetTimer(NULL, 0, 10, InputIdleCB);
1627a1696,1697
>             _EnterWin16Lock();
> #else
1628a1699
> #endif
1631d1701
<         td.hThread = hThread;
1832c1902
<     CURRENTPTD() = &td;
---
>     SETCURRENTPTD(&td);
1959c2029
< #ifdef i386
---
> #ifdef i386xx
1967,1971c2037,2039
<     // FIXME: Enable the following when we are ready.
<     /*
<     if(ptd->pWOWCompatFlagsEx_Info) {
<        FreeFlagInfo(ptd->pWOWCompatFlagsEx_Info);
<     }
---
>     if(ptd->pWOWCompatFlagsEx_Info) {
>        FreeFlagInfo(ptd->pWOWCompatFlagsEx_Info);
>     }
1973,1976c2041,2043
<     if(ptd->pWOWCompatFlags2_Info) {
<        FreeFlagInfo(ptd->pWOWCompatFlags2_Info);
<     }
<     */
---
>     if(ptd->pWOWCompatFlags2_Info) {
>        FreeFlagInfo(ptd->pWOWCompatFlags2_Info);
>     }
2170a2238,2241
> #ifdef W10
>     _LeaveWin16Lock();
> 	if (CURRENTPTD()->yield_event) CloseHandle(CURRENTPTD()->yield_event);
> #endif
2237a2309,2316
> #ifdef W10
>     _LeaveWin16Lock();
>     if (ptd->yield_event)
> 	{
> 		CloseHandle(ptd->yield_event);
> 		ptd->yield_event = NULL;
> 	}
> #endif
2378a2458
> #if 0	// leecher1337: Seems to be always be 0 on XP and above? Call Fritz!
2382a2463
> #endif
3028a3110
>     DECLARE_THUNKLOCK
3088a3171
>             RELEASE_THUNKLOCK
3100a3184
>             RESTORE_THUNKLOCK
6095,6099c6179,6182
<         // FIXME: Enable the following when we are ready.
<         /*if (WOWCSIDL_AllUsers == pMatchMapPath->dwCLSID) {
<              cb = sizeof(szBuf);
<              GetAllUsersProfileDirectory(szBuf, &cb);
<              }*/
---
>         if (WOWCSIDL_AllUsers == pMatchMapPath->dwCLSID) {
>              cb = sizeof(szBuf);
>              GetAllUsersProfileDirectory(szBuf, &cb);
>              }
--- NT4\private\mvdm\wow32\wuclass.c
+++ nt\private\mvdm\wow32\wuclass.c
22a23,165
> #ifdef W10
> #define NCCR_DEFAULT		0
> #define NCCR_GETCLASSLONG	1
> #define NCCR_SETCLASSLONG	2
> static BOOL mfNCCRmode = NCCR_DEFAULT;
> struct nccr_scl {
> 	int nIndex;
> 	LONG dwNewLong;
> };
> 
> LRESULT CALLBACK W32Win16WndDispProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
> {
> 	VPWNDPROC vpWndProc16 = (VPWNDPROC)GetProp(hwnd, (LPCTSTR)gidWNDPROC16);
> 	LRESULT ret;
> 
> 	/* Special treatment for SetClassLong and GetClassLong handling for x64GetClassLongByClassname
> 	 * and x64SetClassLongByClassname
> 	 */
> 	if (mfNCCRmode)
> 	{
> 		if (uMsg == WM_NCCREATE)
> 		{
> 			LPCREATESTRUCT lpCS = (LPCREATESTRUCT)lParam;
> 			struct nccr_scl *pSCL;
> 
> 			switch (mfNCCRmode)
> 			{
> 			case NCCR_GETCLASSLONG:
> 				*(DWORD*)lpCS->lpCreateParams = GetClassLong(hwnd, *(int*)lpCS->lpCreateParams);
> 				LOGDEBUG(LOG_TRACE,("W32Win16DlgDispProc GetClassLong = %d\n", *(int*)lpCS->lpCreateParams));
> 				break;
> 			case NCCR_SETCLASSLONG:
> 				pSCL = (struct nccr_scl*)lpCS->lpCreateParams;
> 				*(DWORD*)lpCS->lpCreateParams = SetClassLong(hwnd, pSCL->nIndex, pSCL->dwNewLong);
> 				LOGDEBUG(LOG_TRACE,("W32Win16DlgDispProc SetClassLong = %d\n", *(int*)lpCS->lpCreateParams));
> 				break;
> 			}
> 		} else if (uMsg == WM_NCDESTROY)
> 			mfNCCRmode = NCCR_DEFAULT;
> 		
> 		return 0; /* Let CreateWindow fail */
> 	}
> 
> 	if (!vpWndProc16)
> 	{
> 		if (!(vpWndProc16 = (VPWNDPROC)GetClassLong(hwnd, GCL_MY_WNDPROC)))
> 			return 1;
> 		SetProp(hwnd, (LPCTSTR)gidWNDPROC16, (HANDLE)vpWndProc16);
> 	}
> 	if (IsWOWProc(vpWndProc16) && HIWORD(vpWndProc16) != WNDPROC_HANDLE)
> 		ret = W32Win16WndProcEx(hwnd, uMsg, wParam, lParam, vpWndProc16, NULL);
> 	else
> 		ret = CallWindowProc((WNDPROC)vpWndProc16, hwnd, uMsg, wParam, lParam);
> 	if (uMsg == WM_NCDESTROY)
> 		RemoveProp(hwnd, (LPCTSTR)gidWNDPROC16);
> 
> 	return ret;
> }
> 
> // GetClassLong just by Classname
> DWORD x64GetClassLongByClassname(HINSTANCE hInstance, LPCTSTR lpClassName, int nIndex)
> {
> 	HWND hWnd;
> 
> 	// We assume that the caller already verified that it's a WOW window
> 	// Very expensive call here:
> 	// We need to create a window in order to access the GetClassLong pointer.. Any better ideas?
> 	LOGDEBUG(LOG_TRACE,("x64GetClassLongByClassname(%x, %s, %d)\n", hInstance, lpClassName, nIndex));
> 	mfNCCRmode = NCCR_GETCLASSLONG;
> 	hWnd = x64CreateWindowEx(
> 		   0, lpClassName, "WOWDUMMY", WS_DISABLED | WS_POPUP, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, 0,
> 		   NULL, hInstance?hInstance:GetModuleHandle(NULL), &nIndex);
> 	LOGDEBUG(LOG_TRACE,("x64GetClassLongByClassname after call: hwnd=%x, mfNCCRmode=%d\n", hWnd, mfNCCRmode));
> 	if (mfNCCRmode == NCCR_GETCLASSLONG)
> 	{
> 		LOGDEBUG(LOG_ALWAYS,("x64GetClassLongByClassname called on a window that belongs to class %s doesn't react with W32Win16WndDispProc\n", lpClassName));
> 		mfNCCRmode = NCCR_DEFAULT;
> 		if (hWnd) nIndex = (int)GetClassLong(hWnd, nIndex);
> 		else
> 		{
> 			// Something went terribly wrong here
> 			return 0;
> 		}
> 	}
> 	if (hWnd)
> 	{
> 		// Should not happen, as we fail WM_NCCREATE
> 		DestroyWindow(hWnd);
> 	}
> 	LOGDEBUG(LOG_TRACE,("x64GetClassLongByClassname returns %d\n", nIndex));
> 	return (DWORD)nIndex;
> }
> 
> DWORD x64SetClassLongByClassname(HINSTANCE hInstance, LPCTSTR lpClassName, int nIndex, LONG dwNewLong)
> {
> 	HWND hWnd;
> 	struct nccr_scl scl;
> 
> 	// We assume that the caller already verified that it's a WOW window
> 	// Very expensive call here:
> 	// We need to create a window in order to access the SetClassLong pointer.. Any better ideas?
> 	LOGDEBUG(LOG_TRACE,("x64SetClassLongByClassname(%x, %s, %d, %x)\n", hInstance, lpClassName, nIndex, dwNewLong));
> 	mfNCCRmode = NCCR_SETCLASSLONG;
> 	scl.nIndex = nIndex;
> 	scl.dwNewLong = dwNewLong;
> 	hWnd = x64CreateWindowEx(
> 		   0, lpClassName, "WOWDUMMY", WS_DISABLED | WS_POPUP, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, 0,
> 		   NULL, hInstance?hInstance:GetModuleHandle(NULL), &scl);
> 	if (mfNCCRmode == NCCR_SETCLASSLONG)
> 	{
> 		LOGDEBUG(LOG_ALWAYS,("x64SetClassLongByClassname called on a window that belongs to class %s doesn't react with W32Win16WndDispProc\n", lpClassName));
> 		mfNCCRmode = NCCR_DEFAULT;
> 		if (hWnd) scl.nIndex = (int)SetClassLong(hWnd, nIndex, dwNewLong);
> 		else
> 		{
> 			// Something went terribly wrong here
> 			return 0;
> 		}
> 	}
> 	if (hWnd)
> 	{
> 		// Should not happen, as we fail WM_NCCREATE
> 		DestroyWindow(hWnd);
> 	}
> 	LOGDEBUG(LOG_TRACE,("x64SetClassLongByClassname returns %d\n", scl.nIndex));
> 	return (DWORD)scl.nIndex;
> }
> 
> BOOL x64GetClassInfo(HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass)
> {
> 	BOOL bRet = GetClassInfo(hInstance, lpClassName, lpWndClass);
> 	if(bRet && lpWndClass->lpfnWndProc == W32Win16WndDispProc)
> 	{
> 		DWORD dwRet;
> 		
> 		dwRet = x64GetClassLongByClassname(hInstance, lpClassName, GCL_MY_WNDPROC);
> 		if (dwRet) lpWndClass->lpfnWndProc = (WNDPROC)dwRet;
> 		lpWndClass->cbClsExtra -= GWL_OFFSET;
> 	}
> 	return bRet;
> }
> #endif /* W10 */
> 
93c236
<     ul = GETBOOL16(GetClassInfo(hInst, pszClass, &t3));
---
>     ul = GETBOOL16(x64GetClassInfo(hInst, pszClass, &t3));
172a316
> #ifndef W10 /* Not implemented on x64 */
189a334
> #endif
263c408
<                 dwProc32 = GetClassLong(hwnd, iOffset);
---
>                 dwProc32 = GetClassLong(hwnd, GCL_MY_WNDPROC);
308c453
<             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA);
---
>             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA) - GWL_OFFSET;
312c457
<             ul = GetClassLong(hwnd, iOffset);
---
>             ul = GetClassLong(hwnd, iOffset + (iOffset>=0?GWL_OFFSET:0));
427c572
<             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA);
---
>             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA) - GWL_OFFSET;
433c578
<             ul = GetClassWord(hwnd, iOffset);
---
>             ul = GetClassWord(hwnd, iOffset + (iOffset>=0?GWL_OFFSET:0));
497a643,645
> #ifdef W10
>     VPWNDPROC lpfnWndProc;
> #endif
531a680,691
> #ifdef W10
>     // Windows 10 x64 Hack: USER32.DLL for some reason doesn't contain 
>     // code to properly dispatch to W32Win16WndProcEx, when Window handle
>     // is marked as seen above.
>     // Therefore we use a hack and replace WndProc with our own wrapper 
>     // that dispatched to W32Win16WndProcEx. Any better ideas?
>     t1.cbClsExtra += GWL_OFFSET;
>     lpfnWndProc    = (VPWNDPROC)t1.lpfnWndProc;
>     t1.lpfnWndProc = W32Win16WndDispProc;
> #endif
> 
> 
555a716,721
> #ifdef W10
>     else
>     {
>         x64SetClassLongByClassname(HMODINST32(t1.hInstance), pszClass, GCL_MY_WNDPROC, lpfnWndProc);
>     }
> #endif
652c818
<                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_WNDPROC, (LONG)dwWndProc32New);
---
>                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_MY_WNDPROC, (LONG)dwWndProc32New);
664c830
<                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_WNDPROC, l);
---
>                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_MY_WNDPROC, l);
717c883
<             if(IsWOWProc (GetClassLong(HWND32(parg16->f1), GCL_WNDPROC))) {
---
>             if(IsWOWProc (GetClassLong(HWND32(parg16->f1), GCL_MY_WNDPROC))) {
723c889
<                 ul = SetClassLong(HWND32(parg16->f1), iOffset, WORD32(parg16->f3));
---
>                 ul = SetClassLong(HWND32(parg16->f1), iOffset, WORD32(parg16->f3) + GWL_OFFSET);
732c898
<             ul = SetClassLong(HWND32(parg16->f1), iOffset, LONG32(parg16->f3));
---
>             ul = SetClassLong(HWND32(parg16->f1), iOffset + (iOffset>=0?GWL_OFFSET:0), LONG32(parg16->f3));
856c1022
<             if(IsWOWProc (GetClassLong(hwnd, GCL_WNDPROC))) {
---
>             if(IsWOWProc (GetClassLong(hwnd, GCL_MY_WNDPROC))) {
858c1024
<                 ul = SetClassLong(hwnd, GCL_CBCLSEXTRA, (LONG)ul);
---
>                 ul = SetClassLong(hwnd, GCL_CBCLSEXTRA, (LONG)ul + GWL_OFFSET);
869c1035
<             ul = SetClassWord(hwnd, iOffset, (WORD)ul);
---
>             ul = SetClassWord(hwnd, iOffset + (iOffset>=0?GWL_OFFSET:0), (WORD)ul);
--- NT4\private\mvdm\wow32\wow32.c
+++ nt\private\mvdm\wow32\wow32.c
96a97,101
> #ifdef W10
> #include "wtask.h"
> DWORD gdwTLSWOW32Reserved;
> ATOM  gidWNDPROC16, gidDLGPROC16;
> #endif
133c138
< #ifndef _X86_
---
> #ifndef _X86xx_
409a415,418
> #ifdef W10
>         GlobalDeleteAtom(gidWNDPROC16);
>         GlobalDeleteAtom(gidDLGPROC16);
> #endif
625c634
< #ifndef _X86_
---
> #ifndef _X86xx_
691a701,720
> #ifdef W10
>     pfnOut.pfnYieldTask = (PFNYIELDTASK)xxxUserYield;
> 	pfnOut.pfnDirectedYield = (PFNDIRECTEDYIELD)xxxDirectedYield;
>     pfnOut.pfnWowWaitForMsgAndEvent = xxxWaitForMsgAndEvent;
>     ptd = malloc_w_or_die(sizeof(TD));
>     gdwTLSWOW32Reserved = TlsAlloc();
>     TlsSetValue(gdwTLSWOW32Reserved, ptd);
>     gidWNDPROC16 = GlobalAddAtom("WNDPROC16");
>     gidDLGPROC16 = GlobalAddAtom("DLGPROC16");
>     if (GetEnvironmentVariableOem("WOWTRACE", szLogFile, sizeof(szLogFile)))
> 	{
> 		char szLogLvl[32];
> 		if (GetEnvironmentVariableOem("WOWLOGLVL", szLogLvl, sizeof(szLogLvl)))
> 			iLogLevel = atoi(szLogLvl);
> 		fLog = 2;
> 	}
>     // create dummy menu window, something like this exists on windows xp created by csrss
>     // but is missing on windows starting with Win 7/conhost
>     CreateWindowExA(0x181, "#32768", "", 0x84800000, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
> #else
692a722
> #endif
1944c1974
< #ifdef _X86_
---
> #ifdef _X86xx_
2136c2166
<                                    FILE_SHARE_WRITE,
---
>                                    FILE_SHARE_WRITE | FILE_SHARE_READ,
--- NT4\private\mvdm\wow32\wudlg.c
+++ nt\private\mvdm\wow32\wudlg.c
22a23,75
> #ifdef W10
> struct init_param {
> 	LPARAM lParam;
> 	WNDPROC  vpDlgProc;
> };
> volatile VPWNDPROC gvpWndProc16 = NULL;
> 
> 
> BOOL CALLBACK W32Win16DlgDispProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
> {
> 	VPWNDPROC vpWndProc16;
> 	BOOL bRet;
> 
> 	if (uMsg == WM_INITDIALOG)
> 	{
> 		struct init_param *param = (struct init_param*)lParam;
> 		
> 		SetProp(hwndDlg, (LPCTSTR)gidDLGPROC16, (HANDLE)param->vpDlgProc);
> 		vpWndProc16 = param->vpDlgProc;
> 		lParam = param->lParam;
> 	}
> 	else
> 	{
> 		vpWndProc16 = (VPWNDPROC)GetProp(hwndDlg, (LPCTSTR)gidDLGPROC16);
> 		if (!vpWndProc16 && gvpWndProc16)
> 		{
> 			/* First set it to global WndProc until we get the real one in WM_INITDIALOG 
> 			 * Better than NULL
> 			 */
> 			SetProp(hwndDlg, (LPCTSTR)gidDLGPROC16, (HANDLE)gvpWndProc16);
> 			gvpWndProc16 = NULL;
> 		}
> 	}
> 	if (!vpWndProc16)
> 	{
> 		LOGDEBUG(LOG_ALWAYS, ("W32Win16DlgDispProc: hWnd %x: vpWndProc=NULL!\n", hwndDlg)); 
> 	}
> 
> 	LOGDEBUG(LOG_TRACE,("W32Win16DlgDispProc (%x, %x, %x, %x) vpWndProc=%x, WOW=%d\n", hwndDlg, uMsg, wParam, lParam, vpWndProc16, IsWOWProc(vpWndProc16)));
> 
> 	if (IsWOWProc(vpWndProc16))
> 		bRet = W32Win16DlgProcEx(hwndDlg, uMsg, wParam, lParam, vpWndProc16, NULL);
> 	else
> 		bRet = CallWindowProc((WNDPROC)vpWndProc16, hwndDlg, uMsg, wParam, lParam);
> 
> 	if (uMsg == WM_NCDESTROY)
> 		RemoveProp(hwndDlg, (LPCTSTR)gidDLGPROC16);
> 	return bRet;
> }
> #endif /* W10 */
> 
> 
> 
142a196,197
>     LPARAM   lParam;
>     DECLARE_THUNKLOCK
172a228,238
> #ifdef W10
>         struct init_param param;
> 
>         param.lParam = (LPARAM) DWORD32(parg16->f5);
>         param.vpDlgProc = gvpWndProc16 = vpDlgProc;
>         lParam = (LPARAM)&param;
>         vpDlgProc = (WNDPROC)W32Win16DlgDispProc;
>         RELEASE_THUNKLOCK
> #else
>         lParam = (LPARAM) DWORD32(parg16->f5);
> #endif
179c245
<                             (LPARAM) DWORD32(parg16->f5), SCDLG_ANSI));
---
>                             lParam, SCDLG_ANSI));
185c251
<                             (LPARAM) DWORD32(parg16->f5),  SCDLG_CLIENT | SCDLG_ANSI | SCDLG_NOREVALIDATE));
---
>                             lParam,  SCDLG_CLIENT | SCDLG_ANSI | SCDLG_NOREVALIDATE));
190a257
>         RESTORE_THUNKLOCK
598a666
>     DECLARE_THUNKLOCK
603a672
>     RELEASE_THUNKLOCK
617a687
>     RESTORE_THUNKLOCK
751a822
>     DECLARE_THUNKLOCK
754a826
>     RELEASE_THUNKLOCK
760a833
>     RESTORE_THUNKLOCK
806a880
>     DECLARE_THUNKLOCK
811a886
>     RELEASE_THUNKLOCK
817a893
>     RESTORE_THUNKLOCK
964a1041
>     DECLARE_THUNKLOCK
987a1065
>     RELEASE_THUNKLOCK
991a1070
>     RESTORE_THUNKLOCK
1030a1110
>     DECLARE_THUNKLOCK
1033a1114
>     RELEASE_THUNKLOCK
1037a1119
>     RESTORE_THUNKLOCK
1229a1312
>     DECLARE_THUNKLOCK
1247a1331
>     RELEASE_THUNKLOCK
1253a1338
>     RESTORE_THUNKLOCK
1298a1384
>     DECLARE_THUNKLOCK
1303a1390
>     RELEASE_THUNKLOCK
1309a1397
>     RESTORE_THUNKLOCK
1343a1432
>     DECLARE_THUNKLOCK
1353a1443
>     RELEASE_THUNKLOCK
1358a1449
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wuwind.c
+++ nt\private\mvdm\wow32\wuwind.c
751c751,752
<     hwnd32 = (pfnOut.pfnCsCreateWindowEx)(
---
> 
>     hwnd32 = x64CreateWindowEx(
763,764c764
<                vpparam,
<                CW_FLAGS_ANSI);
---
>                vpparam);
788c788
<         LOGDEBUG(LOG_WARNING,("  CreateWindow failed, class = %s\n", pszClass));
---
>         LOGDEBUG(LOG_WARNING,("  CreateWindow failed, class = %s, gle=%d\n", pszClass, GetLastError()));
898a899
>     DECLARE_THUNKLOCK
901a903
>     RELEASE_THUNKLOCK
902a905
>     RESTORE_THUNKLOCK
1446c1449
<     register PWW pww;
---
>     register PWW pww = NULL;
1482a1486
> 
1483a1488,1500
> #ifdef W10
>                 switch ( iOffset )
>                 {
>                     case DWL_DLGPROC:
>                         if (dwWndProc32Cur == W32Win16DlgDispProc)
>                             dwWndProc32Cur = GetProp(HWND32(parg16->f1), (LPCTSTR)gidDLGPROC16);
>                         break;
>                     case GWL_WNDPROC:
>                         if (dwWndProc32Cur == W32Win16WndDispProc)
>                             dwWndProc32Cur = GetProp(HWND32(parg16->f1), (LPCTSTR)gidWNDPROC16);
>                         break;
>                 }
> #endif
1610c1627
<     dwThreadID = GetWindowThreadProcessId(HWND32(parg16->f1), &dwProcessID);
---
>     dwThreadID = GetWindowThreadProcessId(FULLHWND32(parg16->f1), &dwProcessID);
1665a1683
>     DECLARE_THUNKLOCK
1670a1689
>     RELEASE_THUNKLOCK
1671a1691
>     RESTORE_THUNKLOCK
1725c1745
<     PWW pww;
---
>     PWW pww = NULL;
1999a2020
>     DECLARE_THUNKLOCK
2020a2042
>             RELEASE_THUNKLOCK
2022a2045
>             RESTORE_THUNKLOCK
2027a2051
>     RELEASE_THUNKLOCK
2033a2058
>     RESTORE_THUNKLOCK
2105a2131
>     DECLARE_THUNKLOCK
2110a2137
>     RELEASE_THUNKLOCK
2117a2145
>     RESTORE_THUNKLOCK
2175c2203
<     register PWW pww;
---
>     register PWW pww = NULL;
2198a2227
>             LONG    l;
2212d2240
<                 dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, dwWndProc32New);
2214,2217c2242
<                 // If the 32 bit set failed, perhaps because its another process,
<                 // then we want to fail too
<                 if (!dwWndProc32Old)
<                     goto SWL_Cleanup;
---
>                 l = dwWndProc32New;
2223c2248
<                 LONG    l;
---
>                 
2238c2263,2286
<                 dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, l);
---
>             }
> 
> #ifdef W10
>             dwWndProc32Old = GetWindowLong(HWND32(parg16->f1), iOffset);
>             switch ( iOffset )
>             {
>                 case DWL_DLGPROC:
>                     if (dwWndProc32Old == W32Win16DlgDispProc)
>                         dwWndProc32Old = GetProp(HWND32(parg16->f1), (LPCTSTR)gidDLGPROC16);
>                     else
>                         SetWindowLong(HWND32(parg16->f1), iOffset, W32Win16DlgDispProc);
>                     SetProp(HWND32(parg16->f1), gidDLGPROC16, (HANDLE)l);
>                     break;
>                 case GWL_WNDPROC:
>                     if (dwWndProc32Old == W32Win16WndDispProc)
>                         dwWndProc32Old = GetProp(HWND32(parg16->f1), (LPCTSTR)gidWNDPROC16);
>                     else
>                         SetWindowLong(HWND32(parg16->f1), iOffset, W32Win16WndDispProc);
>                     SetProp(HWND32(parg16->f1), gidWNDPROC16, (HANDLE)l);
>                     break;
>             }
> #else
>             dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, l);
> #endif
2240,2243c2288,2291
<                 // If the 32 bit set failed, perhaps because its another process,
<                 // then we want to fail too
<                 if (!dwWndProc32Old)
<                     goto SWL_Cleanup;
---
>             // If the 32 bit set failed, perhaps because its another process,
>             // then we want to fail too
>             if (!dwWndProc32Old)
>                 goto SWL_Cleanup;
2245d2292
<             }
2306c2353,2358
<         ul = SetWindowLong(HWND32(parg16->f1), iOffset, new);
---
>         ul = SetWindowLong(FULLHWND32(parg16->f1), iOffset, new);
> 		{
> 			ULONG chk = GetWindowLong(FULLHWND32(parg16->f1), iOffset);
> 			WOW32ASSERT(chk == new);
> 		}
> 
2387a2440
>     DECLARE_THUNKLOCK
2390a2444
>     RELEASE_THUNKLOCK
2407a2462
>     RESTORE_THUNKLOCK
2499a2555
>     DECLARE_THUNKLOCK
2503a2560
>     RELEASE_THUNKLOCK
2521a2579
>     RESTORE_THUNKLOCK
2548a2607
>     DECLARE_THUNKLOCK
2564a2624
>     RELEASE_THUNKLOCK
2565a2626
>     RESTORE_THUNKLOCK
2615c2676
<     PWW pww;
---
>     PWW pww = NULL;
2632c2693
<     hwnd = HWND32(parg16->f1);
---
>     hwnd = FULLHWND32(parg16->f1);
2737a2799
>     DECLARE_THUNKLOCK
2740a2803
>     RELEASE_THUNKLOCK
2743a2807
>     RESTORE_THUNKLOCK
2776a2841,2964
> 
> enum ZBID
> {
> 	ZBID_DEFAULT = 0,
> 	ZBID_DESKTOP = 1,
> 	ZBID_UIACCESS = 2,
> 	ZBID_IMMERSIVE_IHM = 3,
> 	ZBID_IMMERSIVE_NOTIFICATION = 4,
> 	ZBID_IMMERSIVE_APPCHROME = 5,
> 	ZBID_IMMERSIVE_MOGO = 6,
> 	ZBID_IMMERSIVE_EDGY = 7,
> 	ZBID_IMMERSIVE_INACTIVEMOBODY = 8,
> 	ZBID_IMMERSIVE_INACTIVEDOCK = 9,
> 	ZBID_IMMERSIVE_ACTIVEMOBODY = 10,
> 	ZBID_IMMERSIVE_ACTIVEDOCK = 11,
> 	ZBID_IMMERSIVE_BACKGROUND = 12,
> 	ZBID_IMMERSIVE_SEARCH = 13,
> 	ZBID_GENUINE_WINDOWS = 14,
> 	ZBID_IMMERSIVE_RESTRICTED = 15,
> 	ZBID_SYSTEM_TOOLS = 16,
> 
> 	//Windows 10+
> 	ZBID_LOCK = 17,
> 	ZBID_ABOVELOCK_UX = 18,
> };
> 
> typedef HWND    (WINAPI *PFNCSCREATEWINDOWEX10)(DWORD dwExStyle, LPCTSTR lpClassName,
>         LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam, enum ZBID Band, DWORD Flags);
> 
> 
> /*++
> 	Windows version dependent PFNCSCREATEWINDOWEX to support multiple Windows 
> 	Versions
> --*/
> HWND x64CreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, 
> 					   int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, 
> 					   HANDLE hInstance, LPVOID lpParam)
> {
> 	static int iHasZbid = -1;
>     BOOL fRelease = FALSE;
>     HWND hWndRet;
>     DECLARE_THUNKLOCK
> 
> 	if (iHasZbid < 0)
> 	{
> 		OSVERSIONINFO ovi = {0};
> 
> 		ovi.dwOSVersionInfoSize = sizeof(ovi);
> 		if (GetVersionEx(&ovi))
> 		{
> 			switch (ovi.dwMajorVersion)
> 			{
> 			default:
> 			case 5: /* Windows 2000-XP */
> 				iHasZbid = 0;
> 				break;
> 			case 6: /* Windows Vista, 7, 8 */
> 				switch (ovi.dwMinorVersion)
> 				{
> 				case 0: /* Windows Vista */
> 				case 1: /* Windows 7 */
> 					iHasZbid = 0;
> 					break;
> 				case 2: /* Windows 8.0 */
> 				case 3: /* Windows 8.1 */
> 					iHasZbid = 1;
> 					break;
> 				}
> 				break;
> 			case 10: /* Windows 10 */
> 				iHasZbid = 1;
> 				break;
> 			}
> 		}
> 	}
> 
>     if (hWndParent && IsWindow(hWndParent))
>     {
>         DWORD dwWinTid = GetWindowThreadProcessId(hWndParent, NULL);
> 
>         if (!dwWinTid) dwWinTid = GetWindowThreadProcessId(FULLHWND32(hWndParent), NULL);
>         fRelease = dwWinTid != GetCurrentThreadId();
>     }
>     if (fRelease) RELEASE_THUNKLOCK
> 
> 	if (iHasZbid > 0)
> 	{
> 		hWndRet = (((PFNCSCREATEWINDOWEX10)pfnOut.pfnCsCreateWindowEx))(
> 			   dwExStyle,
> 			   lpClassName,
> 			   lpWindowName,
> 			   dwStyle,
> 			   X,
> 			   Y,
> 			   nWidth,
> 			   nHeight,
> 			   hWndParent,
> 			   hMenu,
> 			   hInstance,
> 			   lpParam,
> 			   ZBID_DEFAULT,
> 			   CW_FLAGS_ANSI);
> 	}
>     else
>     {
>         hWndRet = (pfnOut.pfnCsCreateWindowEx)(
>                dwExStyle,
>                lpClassName,
>                lpWindowName,
>                dwStyle,
>                X,
>                Y,
>                nWidth,
>                nHeight,
>                hWndParent,
>                hMenu,
>                hInstance,
>                lpParam,
>                CW_FLAGS_ANSI);
>     }
>     if (fRelease) RESTORE_THUNKLOCK
>     
>     return hWndRet;
> }
--- NT4\private\mvdm\wow32\wuwind.h
+++ nt\private\mvdm\wow32\wuwind.h
61a62,65
> 
> HWND x64CreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, 
> 					   int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, 
> 					   HANDLE hInstance, LPVOID lpParam);
--- NT4\private\mvdm\wow32\wmsg16.c
+++ nt\private\mvdm\wow32\wmsg16.c
130c130
<     lpmpex->hwnd   = HWND32(lpmpex->Parm16.WndProc.hwnd);
---
>     lpmpex->hwnd   = FULLHWND32(lpmpex->Parm16.WndProc.hwnd);
1398,1399d1397
<      // FIXME: Enable the following when we are ready.
<      /*
1411d1408
<     */
1674,1675d1670
<     // NOTE: Enable the following when we are ready.
<     /*
1686d1680
<     */
--- NT4\private\mvdm\wow32\wow32.h
+++ nt\private\mvdm\wow32\wow32.h
19a20
> #define W10	// Enable Windows 10 support for some special weird x64 treatment
45c46
< //#include <tsappcmp.h>
---
> #include <tsappcmp.h>
142a144,174
> #ifdef W10
> /* In 64bit Windows, WOW32Reserved is used by WOW64 to store pointer to 
>  * syscall dispatcher, therefore we unfortunately have to reserve our
>  * own slot for WOW32 data
>  */
> extern DWORD gdwTLSWOW32Reserved;
> #define CURRENTPTD()        ((PTD)TlsGetValue(gdwTLSWOW32Reserved))
> #define SETCURRENTPTD(x)	TlsSetValue(gdwTLSWOW32Reserved, x)
> 
> /* Functions that do special treatment to compensate missing scheduler
>  * support in NtUser
>  */
> extern BOOL x64GetClassInfo(HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass);
> extern ATOM  gidWNDPROC16, gidDLGPROC16;
> 
> // Offsets to store our Win16 WndProc in class
> #define GWL_OFFSET			sizeof(VPWNDPROC)
> #define GCL_MY_WNDPROC		0
> 
> // Locking functions for Win16Mutex for our "special" scheduler (wsyslevel.c)
> typedef struct tagSYSLEVEL
> {
>     CRITICAL_SECTION crst;
>     INT              level;
> } SYSLEVEL;
> 
> #define DECLARE_THUNKLOCK	
> #define RELEASE_THUNKLOCK	{_LeaveWin16Lock();}
> #define RESTORE_THUNKLOCK	{_EnterWin16Lock();}
> 
> #else // W10
143a176
> #define SETCURRENTPTD(x)	CURRENTPTD() = x
144a178,185
> #define x64GetClassInfo		GetClassInfo
> #define GWL_OFFSET			0
> #define GCL_MY_WNDPROC		GCL_WNDPROC
> 
> #define DECLARE_THUNKLOCK	
> #define RELEASE_THUNKLOCK	
> #define RESTORE_THUNKLOCK	
> #endif // W10
264a306,311
> #ifdef W10
>     DWORD               sys_count[4];   /* syslevel mutex entry counters */
>     struct tagSYSLEVEL *sys_mutex[4];   /* syslevel mutex pointers */
>     HANDLE              yield_event;    /* yield event */
>     HANDLE              yield_wait_event;/* yield event */
> #endif
381c428
< #ifndef _X86_
---
> #ifndef _X86xx_
551c598
< #ifndef _X86_  // emulated CPU
---
> #ifndef _X86xx_  // emulated CPU
561c608
< #ifndef _X86_
---
> #ifndef _X86xx_
808c855
< //PTERMSRVCORINIFILE gpfnTermsrvCORIniFile;
---
> PTERMSRVCORINIFILE gpfnTermsrvCORIniFile;
811a859,884
> /* Functions missing from Win2k source */
> #define IsWOWProc(proc) ((((DWORD)proc)&WNDPROC_WOWPROC)==WNDPROC_WOWPROC)
> #define MarkWOWProc(p,pArg) (*(DWORD*)&pArg)=(DWORD)((DWORD)p & 0xFFF9FFFF | ((DWORD)p>>13) & 0x60000 | WNDPROC_WOWPROC);
> #define UnMarkWOWProc(p,pArg) (*(DWORD*)&pArg)=(DWORD)(((DWORD)p<<13) ^ ((DWORD)p ^ ((DWORD)p<<13)) & 0x3FF9FFFF | 0x60000);
>  
> #define WM_CHANGEUISTATE 0x0127
> #define WM_UPDATEUISTATE 0x0128
> #define WM_QUERYUISTATE  0x0129
> #define LVN_HOTTRACK (LVN_FIRST-21)
> #define PSN_HASHELP (PSN_FIRST-4)
> #define PSN_GETOBJECT (PSN_FIRST-10)
> #define PSN_TRANSLATEACCELERATOR (PSN_FIRST-12)
> #define PSN_QUERYINITIALFOCUS (PSN_FIRST-13)
> #define PSN_LASTCHANCEAPPLY (PSN_FIRST-14)
> #define TVN_GETINFOTIPA (TVN_FIRST-13)
> #define TVN_GETINFOTIPW (TVN_FIRST-14)
> #define TVN_SINGLEEXPAND (TVN_FIRST-15)
> #define GCL_WOWMENUNAME (-29)
> #define FR_PRIVATE     0x10
> #define FR_NOT_ENUM    0x20
> #define WOW_CHOOSECOLOR	1
> #define WOW_CHOOSEFONT	2
> #define WOW_OPENFILENAME	3
> #define WOW_PRINTDLG	4
> #define WF_DIALOG_WINDOW	0x10000
> #define HTW_IS16BIT	0x80000000
812a886,887
> #include <commctrl.h>
> #include <wtypes.h>
813a889,929
> typedef struct tagNMKEY
> {
>     NMHDR hdr;
>     UINT  nVKey;
>     UINT  uFlags;
> } NMKEY, *LPNMKEY;
> typedef struct tagNMTVGETINFOTIPA
> {
>     NMHDR hdr;
>     LPSTR pszText;
>     int cchTextMax;
>     HTREEITEM hItem;
>     LPARAM lParam;
> } NMTVGETINFOTIPA, *LPNMTVGETINFOTIPA;
> #ifdef UNICODE
> #define TVN_GETINFOTIP          TVN_GETINFOTIPW
> #define NMTVGETINFOTIP          NMTVGETINFOTIPW
> #define LPNMTVGETINFOTIP        LPNMTVGETINFOTIPW
> #else
> #define TVN_GETINFOTIP          TVN_GETINFOTIPA
> #define NMTVGETINFOTIP          NMTVGETINFOTIPA
> #define LPNMTVGETINFOTIP        LPNMTVGETINFOTIPA
> #endif
> typedef struct tagNMOBJECTNOTIFY {
>     NMHDR   hdr;
>     int     iItem;
> #ifdef __IID_DEFINED__
>     const IID *piid;
> #else
>     const void *piid;
> #endif
>     void *pObject;
>     HRESULT hResult;
>     DWORD dwFlags;    // control specific flags (hints as to where in iItem it hit)
> } NMOBJECTNOTIFY, *LPNMOBJECTNOTIFY;
> typedef struct _DRAWPATRECT {
>         POINT ptPosition;
>         POINT ptSize;
>         WORD wStyle;
>         WORD wPattern;
> } DRAWPATRECT, *PDRAWPATRECT;
814a931,944
> WINGDIAPI int  WINAPI AddFontResourceExA( LPCSTR name, DWORD fl, PVOID res);
> WINGDIAPI int  WINAPI AddFontResourceExW( LPCWSTR name, DWORD fl, PVOID res);
> #ifdef UNICODE
> #define AddFontResourceEx  AddFontResourceExW
> #else
> #define AddFontResourceEx  AddFontResourceExA
> #endif // !UNICODE
> WINGDIAPI int  WINAPI GetRandomRgn (HDC hdc, HRGN hrgn, INT i);
> 
> /* End Functions missing from Win2k source */
> 
> 
> 
> 
--- NT4\private\mvdm\wow32\wmdisp32.c
+++ nt\private\mvdm\wow32\wmdisp32.c
3257,3258d3256
<             // FIXME: Enable the following when we are ready.
<             /*
3261d3258
<             */
3286,3287d3282
<             // FIXME: Enable the following when we are ready.
<             /*
3290d3284
<             */
3310,3311d3303
<             // FIXME: Enable the following when we are ready.
<             /*
3322d3313
<             */
3379,3380d3369
<             // FIXME: Enable the following when we are ready.
<             /*
3383d3371
<             */
3398,3399d3385
<             // FIXME: Enable the following when we are ready.
<             /*
3403d3388
<             */
--- NT4\private\mvdm\wow32\wgdi.c
+++ nt\private\mvdm\wow32\wgdi.c
1686,1687d1685
<         // FIXME: Enable the following when we are ready.
<         /*
1742d1739
<         */
--- NT4\private\mvdm\wow32\wparam.c
+++ nt\private\mvdm\wow32\wparam.c
359c359
<             LOGDEBUG(12, ("\nWOW: DeleteParamMap called refCount > 0 Node@%x\n", (DWORD)lpn));
---
>             LOGDEBUG(12, ("\nWOW: DeleteParamMap called refCount %d > 0 Node@%x\n", lpn->dwRefCount, (DWORD)lpn));
--- NT4\private\mvdm\wow32\wuclass.h
+++ nt\private\mvdm\wow32\wuclass.h
26a27,29
> #ifdef W10
> LRESULT CALLBACK W32Win16WndDispProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
> #endif
--- NT4\private\mvdm\wow32\wudlg.h
+++ nt\private\mvdm\wow32\wudlg.h
40a41,43
> #ifdef W10
> BOOL  CALLBACK   W32Win16DlgDispProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
> #endif
--- NT4\private\mvdm\wow32\wudlg.h
+++ nt\private\mvdm\wow32\wudlg.h
21a22,48
> /* WOW class/handle type identifiers (see WARNING below)
>  */
> #define WOWCLASS_UNKNOWN    0   // here begin our "window handle" classes
> #define WOWCLASS_WIN16      1
> #define WOWCLASS_BUTTON     2
> #define WOWCLASS_COMBOBOX   3
> #define WOWCLASS_EDIT       4
> #define WOWCLASS_LISTBOX    5
> #define WOWCLASS_MDICLIENT  6
> #define WOWCLASS_SCROLLBAR  7
> #define WOWCLASS_STATIC     8
> #define WOWCLASS_DESKTOP    9
> #define WOWCLASS_DIALOG     10
> #define WOWCLASS_ICONTITLE  11
> #define WOWCLASS_MENU       12
> #define WOWCLASS_SWITCHWND  13
> #define WOWCLASS_COMBOLBOX  14
> #define WOWCLASS_MAX        14  // Always equal to the last value used.
> 
> #define WOWCLASS_NOTHUNK    0xFF // not an actual class index
> //
> // WARNING! The above sequence and values must be maintained otherwise the
> // table in WMSG16.C for message thunking must be changed.  Same goes for
> // table in WALIAS.C.
> //
> 
> 
--- NT4\private\mvdm\wow32\walias.c
+++ nt\private\mvdm\wow32\walias.c
626a627
>     LONG   Pid;
629a631
>     LONG   l4;
--- NT4\private\mvdm\wow32\wuman.c
+++ nt\private\mvdm\wow32\wuman.c
189,194c189,191
<                         if ( i & 3 ) {
<                             pszFormat = ", %s";
<                         } else {
<                             pszFormat = "\n%s";
<                         }
<                         LOGDEBUG(LOG_TRACE, (pszFormat, aw32Msg[wMsg].lpszW32));
---
>                         if (aw32Msg[wMsg].lpszW32) pszFormat=( i & 3 )?", %s":"\n%s";
>                         else pszFormat=( i & 3 )?", UNKNOWN (%d)":"\n UNKNOWN (%d)";
>                         LOGDEBUG(LOG_TRACE, (pszFormat, aw32Msg[wMsg].lpszW32?aw32Msg[wMsg].lpszW32:wMsg));
--- NT4\private\mvdm\wow32\wmtbl32.c
+++ nt\private\mvdm\wow32\wmtbl32.c
213c213
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_LPKDRAWSWITCHWND")},
219,225c219,225
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHDESTROYWINDOW")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHDRAWMENU")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHDRAWMENUITEM")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHINITMENU")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHMEASUREMENUITEM")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHNCPAINTMENUPOPUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHUPDATE")},
252,256c252,256
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCXBUTTONDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCXBUTTONUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCXBUTTONDBLCLK")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCUAHDRAWCAPTION")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCUAHDRAWFRAME")},
308a309,310
>     {W32MSGFUN(WM32UNDOCUMENTED,      "EM_SETIMESTATUS")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "EM_GETIMESTATUS")},
310,311d311
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
355,356c355,356
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_INPUT_DEVICE_CHANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_INPUT")},
370c370
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UNICHAR")},
390,393c390,393
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTURE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTURENOTIFY")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTUREINPUT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTURENOTIFIED")},
480a481,483
>     {W32MSGFUN(WM32UNDOCUMENTED,      "CB_MSGMAX_OLD")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "CB_MULTIPLEADDSTRING")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "CB_GETCOMBOBOXINFO")},
482,484d484
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
578a579,581
>     {W32MSGFUN(WM32UNDOCUMENTED,      "LB_MSGMAX_OLD")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "LB_MULTIPLEADDSTRING")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "LB_GETLISTBOXINFO")},
580,582d582
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
691,695c691,695
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSEWHEEL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_XBUTTONDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_XBUTTONUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_XBUTTONDBLCLK")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSEHWHEEL")},
749,754c749,754
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICECHANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEINRANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEOUTOFRANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_STOPINERTIA")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_ENDINERTIA")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_EDGYINERTIA")},
759,766c759,766
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TOUCH")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERUPDATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERLAST")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERUPDATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERUP")},
770,776c770,776
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERENTER")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERLEAVE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERACTIVATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERCAPTURECHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TOUCHHITTESTING")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERWHEEL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERHWHEEL")},
786c786
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERLAST")},
819,822c819,822
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_VISIBILITYCHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_VIEWSTATECHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UNREGISTER_WINDOW_SERVICES")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_CONSOLIDATED")},
883,886c883,886
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCMOUSEHOVER")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSEHOVER")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCMOUSELEAVE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSELEAVE")},
900c900
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TRACKMOUSEEVENT_LAST")},
904c904
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_WTSSESSION_CHANGE")},
923c923
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TABLET_FIRST")},
933,934c933,934
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEADDED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEDELETED")},
936c936
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FLICK")},
938,939c938,939
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FLICKINTERNAL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_BRIGHTNESSCHANGED")},
960c960
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TABLET_LAST")},
963c963
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DPICHANGED")},
1034,1040c1034,1040
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_APPCOMMAND")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_THEMECHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHINIT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DESKTOPNOTIFY")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_CLIPBOARDUPDATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMCOMPOSITIONCHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMNCRENDERINGCHANGED")},
1043,1050c1043,1050
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMCOLORIZATIONCOLORCHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMWINDOWMAXIMIZEDCHANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMEXILEFRAME")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMSENDICONICTHUMBNAIL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MAGNIFICATION_STARTED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MAGNIFICATION_ENDED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMSENDICONICLIVEPREVIEWBITMAP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMTHUMBNAILSIZECHANGED")},
1053,1055c1053,1055
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MAGNIFICATION_OUTPUT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_BSDRDATA")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMTRANSITIONSTATECHANGED")},
1057,1060c1057,1060
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_KEYBOARDCORRECTIONCALLOUT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_KEYBOARDCORRECTIONACTION")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UIACTION")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_ROUTED_UI_EVENT")},
1063,1064c1063,1064
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MEASURECONTROL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GETACTIONTEXT")},
1066,1067c1066,1067
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FORWARDKEYDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FORWARDKEYUP")},
1079,1080c1079,1080
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_CE_ONLY_LAST")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GETTITLEBARINFOEX")},
--- NT4\private\mvdm\wow32\wow32.def
+++ nt\private\mvdm\wow32\wow32.def
45a46,51
> 
>     szLogFile
>     fLog
>     hfLog
>     iLogLevel
> 
--- NT4\private\mvdm\wow32\wcuricon.c
+++ nt\private\mvdm\wow32\wcuricon.c
1101c1101
<          WOW32ASSERT(h32);
---
>          //WOW32ASSERT(h32);
--- NT4\private\mvdm\wow32\wdib.c
+++ nt\private\mvdm\wow32\wdib.c
297c297
< #ifndef i386
---
> #ifndef MONITOR
422c422
< #ifndef i386
---
> #ifndef MONITOR
655c655
< #ifndef i386
---
> #ifndef MONITOR
711c711
< #ifndef i386
---
> #ifndef MONITOR
736c736
< #ifndef i386
---
> #ifndef MONITOR
837c837
< #ifndef i386
---
> #ifndef MONITOR
--- NT4\private\mvdm\wow32\wuser31.c
+++ nt\private\mvdm\wow32\wuser31.c
133a134
>     DECLARE_THUNKLOCK
138a140
>     RELEASE_THUNKLOCK
142a145
>     RESTORE_THUNKLOCK
192c195
< #ifndef _X86_
---
> #ifndef _X86xx_
266c269
< #ifndef _X86_
---
> #ifndef _X86xx_
294c297
< #ifndef _X86_
---
> #ifndef _X86xx_
525c528
< #ifndef _X86_
---
> #ifndef _X86xx_
545c548
< #ifndef _X86_
---
> #ifndef _X86xx_
628c631
< #ifndef _X86_
---
> #ifndef _X86xx_
--- NT4\private\mvdm\wow32\wkmem.c
+++ nt\private\mvdm\wow32\wkmem.c
33c33
< #ifndef i386
---
> #ifndef MONITOR
40c40
< #ifndef i386
---
> #ifndef MONITOR
48c48
< #endif // i386
---
> #endif // MONITOR
56c56
< #ifndef i386
---
> #ifndef MONITOR
63c63
< #endif // i386
---
> #endif // MONITOR
65c65
< #ifdef i386
---
> #ifdef MONITOR
104c104
< #ifndef i386
---
> #ifndef MONITOR
120c120
< #ifndef i386
---
> #ifndef MONITOR
132c132
< #ifndef i386
---
> #ifndef MONITOR
134c134
< #endif // i386
---
> #endif // MONITOR
--- NT4\private\mvdm\wow32\wole2.c
+++ nt\private\mvdm\wow32\wole2.c
159c159
<     ullOldest = -1;
---
>     ullOldest = (ULONGLONG)-1;
--- NT4\private\mvdm\wow32\wkgthunk.c
+++ nt\private\mvdm\wow32\wkgthunk.c
301a302
>     DECLARE_THUNKLOCK
321a323
>     RELEASE_THUNKLOCK
322a325
>     RESTORE_THUNKLOCK
405a409
>     DECLARE_THUNKLOCK
417a422
>     RELEASE_THUNKLOCK
418a424
>     RESTORE_THUNKLOCK
504c510
< #ifndef i386
---
> #ifndef MONITOR
559a566
>     DECLARE_THUNKLOCK
663a671
>     RELEASE_THUNKLOCK
668a677
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wuser.c
+++ nt\private\mvdm\wow32\wuser.c
2281a2282
> 	DECLARE_THUNKLOCK
2361a2363
> 	RELEASE_THUNKLOCK
2362a2365
> 	RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\sources.inc
+++ nt\private\mvdm\wow32\sources.inc
31,32c31,32
<     #$(SDK_LIB_PATH)\userenv.lib
<     #$(WINDOWS_LIB_PATH)\apphelp.lib \
---
>     $(SDK_LIB_PATH)\userenv.lib \
>     $(WINDOWS_LIB_PATH)\apphelp.lib 
133,134c133,135
<     ..\hack.c
< #   ..\wshimdb.c   \
---
>     ..\wshimdb.c   \
>     ..\wsyslevel.c \
>     ..\wtask.c
